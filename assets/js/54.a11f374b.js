(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{394:function(t,r,a){"use strict";a.r(r);var e=a(4),s=Object(e.a)({},(function(){var t=this,r=t._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"面向对象设计六大原则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#面向对象设计六大原则"}},[t._v("#")]),t._v(" 面向对象设计六大原则")]),t._v(" "),r("h2",{attrs:{id:"单一职责原则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#单一职责原则"}},[t._v("#")]),t._v(" 单一职责原则")]),t._v(" "),r("p",[t._v("单一职责原则（Single Responsibility Principle），应该有且仅有一个原因引起类的变更。")]),t._v(" "),r("p",[t._v("简单点说，"),r("strong",[t._v("一个类，最好只负责一件事。")])]),t._v(" "),r("h2",{attrs:{id:"开放-封闭原则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#开放-封闭原则"}},[t._v("#")]),t._v(" 开放-封闭原则")]),t._v(" "),r("p",[t._v("开放-封闭原则（Open Close Principle），软件实体（类、模块、函数）等应该可以扩展，但是不可修改。")]),t._v(" "),r("p",[t._v("对于扩展是开放的；对于更改是封闭的。")]),t._v(" "),r("h2",{attrs:{id:"里氏替换原则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#里氏替换原则"}},[t._v("#")]),t._v(" 里氏替换原则")]),t._v(" "),r("p",[t._v("里氏替换原则（Liskov Substitution Principle），子类可以替换父类。")]),t._v(" "),r("h2",{attrs:{id:"依赖倒置原则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#依赖倒置原则"}},[t._v("#")]),t._v(" 依赖倒置原则")]),t._v(" "),r("p",[t._v("依赖倒置原则（Dependency Inversion Principle），抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。")]),t._v(" "),r("p",[t._v("关键点：")]),t._v(" "),r("ul",[r("li",[t._v("高层模块不应该依赖低层模块，两者都应该依赖其抽象")]),t._v(" "),r("li",[t._v("抽象不应该依赖细节")]),t._v(" "),r("li",[t._v("细节应该依赖抽象")])]),t._v(" "),r("h2",{attrs:{id:"接口隔离原则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#接口隔离原则"}},[t._v("#")]),t._v(" 接口隔离原则")]),t._v(" "),r("p",[t._v("接口隔离原则（Interface Segregation Principle）使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。")]),t._v(" "),r("ul",[r("li",[t._v("客户端不应依赖它不需要的接口")]),t._v(" "),r("li",[t._v("类间的依赖关系应该建立在最小的接口上")])]),t._v(" "),r("h2",{attrs:{id:"迪米特原则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#迪米特原则"}},[t._v("#")]),t._v(" 迪米特原则")]),t._v(" "),r("p",[t._v("迪米特原则（Least Knowledge Principle）又称最少知识原则，一个软件实体应当尽可能少地与其他实体发生相互作用。")]),t._v(" "),r("p",[t._v("一个类应该对自己需要调用的类知道得最少，类的内部如何实现、如何复杂都与调用者或者依赖者没关系，调用者或者依赖者只需要知道他需要的方法即可，其他的我一概不关心。")]),t._v(" "),r("h2",{attrs:{id:"参考资料"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://book.douban.com/subject/2243615/",target:"_blank",rel:"noopener noreferrer"}},[t._v("《Head First 设计模式》"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"https://book.douban.com/subject/2334288/",target:"_blank",rel:"noopener noreferrer"}},[t._v("《大话设计模式》"),r("OutboundLink")],1)])])])}),[],!1,null,null,null);r.default=s.exports}}]);